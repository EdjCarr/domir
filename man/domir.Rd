% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/domir.r
\name{domir}
\alias{domir}
\alias{domir.formula}
\alias{domir.formula_list}
\title{Dominance analysis methods}
\usage{
domir(.obj, ...)

\method{domir}{formula}(
  .obj,
  .fct,
  .set = NULL,
  .wst = NULL,
  .all = NULL,
  .adj = FALSE,
  .cdl = TRUE,
  .cpt = TRUE,
  .rev = FALSE,
  ...
)

\method{domir}{formula_list}(
  .obj,
  .fct,
  .set = NULL,
  .wst = NULL,
  .all = NULL,
  .adj = FALSE,
  .cdl = TRUE,
  .cpt = TRUE,
  .rev = FALSE,
  ...
)
}
\arguments{
\item{.obj}{A \code{formula} or \code{formula_list}.

Parsed to produce subsets of elements to submit to \code{.fct}. Always submits
subsets of \code{.obj} that are of the same \code{\link{class}} to \code{.fct} and are always
submitted as the first, unnamed argument.}

\item{...}{Passes arguments to other methods; passes arguments to
the function in \code{.fct}.}

\item{.fct}{A \code{\link{function}}/closure or string function name.

Applied to all subsets of elements as received from \code{.obj}.
Must return a length 1/scalar, numeric, atomic vector.}

\item{.set}{A \code{list}.

Must be comprised of elements of the same class as \code{.obj}.
Elements of the list can be named.}

\item{.wst}{Not yet used.}

\item{.all}{A \code{formula} or \code{formula_list}.

Must be the same class as \code{.obj}.}

\item{.adj}{Logical.

If \code{TRUE} then a model including only an intercept is submitted to \code{.fct}
and the value returned is subtracted from the values returned from all
subsets in the dominance analysis.}

\item{.cdl}{Logical.

If \code{FALSE} then conditional dominance matrix is not computed and
method to produce general dominance statistics changes.}

\item{.cpt}{Logical.

If \code{FALSE} then complete dominance matrix is not computed.}

\item{.rev}{Logical.

If \code{TRUE} then standardized vector, ranks, and complete dominance
designations are reversed in their interpretation.}
}
\value{
Returns an object of \code{\link{class}} "domir" which is a composed of the
following elements:

\describe{
\item{\code{General_Dominance}}{Vector of general dominance values.}
\item{\code{Standardized}}{Vector of general dominance values normalized
to sum to 1.}
\item{\code{Ranks}}{Vector of ranks applied to the general dominance values.}
\item{\code{Conditional_Dominance}}{Matrix of conditional dominance values.
Each row represents an element in \code{.obj};
each column represents a number of elements from \code{.obj} in a subset.}
\item{\code{Complete_Dominance}}{Logical matrix of complete dominance
designations.
The \code{.obj} elements represented in each row indicates dominance status;
the \code{.obj} elements represented in each column indicates
dominated-by status.}
\item{\code{Value}}{Value returned by \code{.fct} with all elements (i.e.,
from \code{.obj}, \code{.all}, and \code{.adj}.}
\item{\code{Value_All}}{Value of \code{.fct} associated with elements included
in \code{.all};
when elements are in \code{.adj}, will be adjusted for \code{Value_Adjust}.}
\item{\code{Value_Adjust}}{Value of \code{.fct} associated with elements in \code{.adj}.}
\item{\code{Call}}{The matched call.}
}
}
\description{
Parses input object to obtain valid elements, determines all required
combinations/subsets of elements (depends on input type), submits subsets to
a function, and computes dominance decomposition
statistics based on the returned values from the function.
}
\details{
\subsection{Element Parsing}{

\code{.obj}s elements are parsed and used to determine the required number of
subsets included the dominance analysis.  How the elements are parsed is
determined depends on \code{.obj}s class method.
\subsection{\code{formula}}{

The \code{formula} method separates all terms in the formula using standard
parsing rules for the right hand side (see \code{\link{formula}} documentation).
Each parsed term is considered a separate element in the dominance analysis.

A response/left hand side is not required but, if present, is retained and
used as the response for all \code{formula} subsets in the dominance analysis.
}

\subsection{\code{formula_list}}{

The \code{formula_list} works the same way as the \code{formula} method except that
the elements from each \code{formula} in the \code{formula_list} are considered
a different response-term element in the dominance analysis.

A response/left hand side is required for each different \code{formula} and each
response must be unique.
}

\subsection{Additional Details}{

By default, each parsed element in \code{.obj} will be used as a separate
element to generate subsets and will obtain a separate contribution to
the returned value.

The presence or absence of an intercept is recorded an passed along to
each subset for both \code{formula}s and \code{formula_list}s.

\code{\link{offset}}s are allowed in \code{formula}s and \code{formula_list}s. \code{offsets} are
parsed and passed along to each subset like the response. \code{offset}s are
then not considered a part of the dominance analysis subsets but an extension
of the model intercept.
}

}

\subsection{Changing Element Parsing}{

All methods' default behavior of using all elements to generate subsets
can be overriden using \code{.set} and \code{.all} arguments.

Elements in \code{.set} and \code{.all} must also be present in \code{.obj}.  The entries
these two arguments change \code{.obj}s parsing behavior but depend on \code{.obj}
as the primary input object and will check entries against those in\code{.obj}.
\subsection{\code{.set}}{

\code{.set} binds together elements in \code{.obj} such that they form a single new
element. The elements in \code{.obj} bound together contribute jointly to the
returned value.

If elements in \code{.set} are named, the \code{.set} element's name will be used
in the "domir" object returned and all printed results.

The \code{formula} method for \code{.set} requires the user to submit a list of
\code{formula}s and does not allow any of the \code{formula}s to have a left hand side.
The terms in each \code{formula} are bound together as a set.
The \code{formula_list} method for \code{.set} requires the user to submit a list of
\code{formula_list}s. The response-term pairs in each \code{formula_list} are bound
together as a set.
}

\subsection{\code{.all}}{

\code{.all} binds elements in \code{.obj} to all subsets. The elements in \code{.obj} bound
together by \code{.all} are given precedence in ascribing the returned value and
contribute jointly to \code{Value_All}. \code{Value_All} is determined prior to
conducting the dominance analysis and its value is removed from the returned
values for all subsets.

The \code{formula} method for \code{.all} does not allow a left hand side.
}

\subsection{\code{.adj}}{

\code{.adj} indicates that an intercept-only model should be supplied to \code{.fct}
and that this intercept-only subset should be given highest precedence in the
dominance analysis. The value ascribed to the intercept-only subset is
returned as \code{Value_Adjust} and its value is removed from the returned
values for all subsets as well as from \code{Value_All}.

The \code{formula_list} method creates a separate, intercept-only subset for each
of the \code{formula}s in the list. Both \code{formula} and \code{formula_list} methods
will respect the user's inclusion of an \code{offset} and removal of an intercept.
\code{offsets} and removed intercepts will be applied in the \code{.adj} subset's
result.
}

\subsection{Additional Details}{

All element parsing methods will submit subsets generated as an
object of the same class as \code{.obj}. Thus a \code{formula} in \code{.obj} will be
submitted as a \code{formula} and a \code{formula_list} in \code{.obj} will be
submitted as a \code{formula_list}. In the case that the predictive model in
\code{.fct} requires a different format (i.e., a vector of names, a
\code{\link[Formula:Formula]{Formula::Formula}} see \code{\link{fmllst2Fml}}) the subset will have to be processed in \code{.fct} to
obtain the correct format.

The subsets will always be submitted to \code{.fct} as the first, unnamed
argument.
}

}

\subsection{\code{.fct} as Analysis Pipeline}{

The function in \code{.fct} will be called repeatedly; once for each subset
of elements created from \code{.obj}.

\code{.fct} is expected to be a complete analysis pipeline that receives a
subset of elements from \code{.obj}, uses the subset of elements from \code{.obj} in
the class as received to generate a predictive model, and
extracts a returned value of the appropriate type to dominance analyze.

At current, only atomic (i.e., non-\code{list}), numeric scalars (i.e.,
vectors of length 1) are allowed as returned values.

The \code{.fct} argument is strict about input and output requirements for
functions used and applies a series of checks to ensure the input and
output adhere to these requirements. The checks include whether the \code{.obj}
can be submitted to \code{.fct} without producing an error and whether the
returned value from \code{.fct} is a length 1, atomic, numeric vector.
In most circumstances, the user will have to make their own named or
anonymous function to supply as \code{.fct} to satisfy the checks.
}
}
\section{Notes}{
\subsection{\code{formula} method}{

Prior to version 1.1.0, the \code{formula} method for \code{.adj} allowed a \code{formula}
to be submitted. Submitting an intercept-only \code{formula} as opposed to a
logical has been depreciated and submitting a formula with more than an
intercept is defunct.

If the user seeks to include factors other than an intercept and \code{offset},
the user could include the additional term in \code{.fct} as an
\code{\link[=update.formula]{update}} to the submitted \code{formula} or \code{formula_list}
element object or through other similar means.

Second-order or higher terms (i.e., interactions like\code{~ a*b}) are parsed
by default but not used differently from first-order terms for producing
subsets. The dominance analysis results from models using such terms may
not produce useful results unless the user ensures that second-order and
higher terms are used appropriately in \code{.fct}.
}
}

\examples{
## Basic linear model with r-square

lm_r2 <- function(fml, data) { 
  lm_res <- lm(fml, data = data)
  r2 <- summary(lm_res)[["r.squared"]]
  return(r2) }

domir(mpg ~ am + vs + cyl, 
  lm_r2,
  data = mtcars)


## Linear model including set

domir(mpg ~ am + vs + cyl + carb + gear + disp + wt,
 lm_r2,
 .set = list(~ carb + gear, ~ disp + wt),
 data = mtcars)


## Multivariate linear model with multivariate r-square
## and all subsets variable

mlm_rxy <- function(fml, data, dvnames) {
  mlm_res <- lm(fml, data = data)
  mlm_pred <- predict(mlm_res)
  mlm_rxy <- cancor(mlm_pred, data[dvnames])$cor[[1]]^2
  return(mlm_rxy)
  }
       
domir(cbind(wt, mpg) ~ vs + cyl + am + carb,
  mlm_rxy, 
  .all = ~ carb,
  data = mtcars, 
  dvnames = c("wt", "mpg"))


## Named sets

domir(mpg ~ am + gear + cyl + vs + qsec + drat,
  lm_r2,
  data = mtcars, 
  .set = list(trns = ~ am + gear, 
    eng = ~ cyl + vs, misc = ~ qsec + drat))
  
  
## Linear model using AIC

lm_aic <- function(fml, data) { 
  lm_res <- lm(fml, data = data)
  aic <- AIC(lm_res)
  return(aic) }

domir(mpg ~ am + carb + cyl, 
  lm_aic, 
  .adj = ~ 1,
  .rev = TRUE,
  data = mtcars)
  
}
