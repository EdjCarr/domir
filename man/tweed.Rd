% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tweed.r
\name{tweed}
\alias{tweed}
\alias{tweed.formula}
\alias{tweed.Formula}
\alias{tweed.list}
\title{The Working Elastic Edition of Dominance analysis (tweed)}
\usage{
tweed(.obj, ...)

\method{tweed}{formula}(
  .obj,
  .fct,
  .set = NULL,
  .all = NULL,
  .adj = NULL,
  .cdl = TRUE,
  .cpt = TRUE,
  .rev = FALSE,
  ...
)

\method{tweed}{Formula}(
  .obj,
  reg,
  fitstat,
  .set = NULL,
  .all = NULL,
  .cdl = TRUE,
  .cpt = TRUE,
  consmodel = NULL,
  .rev = FALSE
)

\method{tweed}{list}(
  .obj,
  reg,
  fitstat,
  .set = NULL,
  .all = NULL,
  .cdl = TRUE,
  .cpt = TRUE,
  consmodel = NULL,
  .rev = FALSE
)
}
\arguments{
\item{.obj}{An object of class \link{formula}, \link[=formula]{Formula}, or \link{list}.

The object submitted to the \code{.obj} argument will be used to determine
the sub-models that will be used in the dominance analysis.

\code{formula}-class entries to \code{.obj} must include the all independent
variables to be used in the dominance analysis.  Each independent variable
separated by \code{+} will be used as an additional subsettor and will contribute
to the total number of models estimated.  A response is not required.

All methods for \code{tweed} will submit an object of the same type to the
function in \code{.fct} as the first, unnamed argument.

All methods' default behavior of using all entries as separate subsettors
can be overriden using \code{.set}, \code{.all}, and \code{.adj} arguments.}

\item{...}{Passes arguments to other methods.}

\item{.fct}{A function.

Controls the predictive modeling function used in the dominance analysis.}

\item{.set}{A list with each element comprised of elements of the same class
as \code{.obj}.

The independent variables referred to in element of the list submitted to
\code{.set} combine elements present in \code{.obj} by binding them into
inseparable set in the dominance analysis. All bound independent variables
are considered a single subsettor.}

\item{.all}{An entry with the same class as \code{.obj}.

The independent variables referred to in this entry are not used as
subsettors.  Rather the value associated with these terms is removed from
the dominance analysis.  The user can think about the independent
variables referred to in this vector is used like a set of covariates.

The entries in \code{.all} are removed from and considered an additional component that explains the fit metric.  As a result, the general dominance statistics will no longer sum to the overall fit metric and the standardized vector will no longer sum to 1.}

\item{.adj}{A vector of variable/factor names, \code{formula} coercible strings, or other formula terms (i.e., 1 to indicate an intercept).  The entries in this vector are concatenated (when of length > 1) and, like the entries of \code{.all}, are not used in the dominance analysis; this vector is used as an adjustment to the baseline value of the overall fit statistic.

The use of \code{consmodel} changes the interpretation of the the general and Conditional dominance statistics.  When \code{consmodel} is used, the general and Conditional dominance statistics are reflect the difference between the constant model and the overall fit statistic values.

Typical usage of \code{consmodel} is to pass "1" to set the intercept as the baseline and control for its value when the baseline model's fit statistic value is not 0 (e.g., if using the AIC or BIC as a fit statistic; see examples).}

\item{.cdl}{Logical.  If \code{FALSE} then Conditional dominance matrix is not computed.

If Conditional dominance is not desired as an importance criterion, avoiding computing the Conditional dominance matrix can save computation time.}

\item{.cpt}{Logical.  If \code{FALSE} then Complete dominance matrix is not computed.

If Complete dominance is not desired as an importance criterion, avoiding computing Complete dominance designations can save computation time.

As such, this vector is used to set a baseline for the fit statistic when it is non-0.}

\item{.rev}{Logical. If \code{TRUE} then standardized vector, ranks, and Complete dominance Designations are reversed in their interpretation.

This argument should be changed to \code{TRUE} if the fit statistic used decreases with better fit to the data (e.g., AIC, BIC).}
}
\value{
Returns an object of \code{\link{class}} "domin".
An object of class "domin" is a list composed of the following elements:
\describe{
\item{\code{General_Dominance}}{Vector of general dominance statistics.}
\item{\code{Standardized}}{Vector of general dominance statistics normalized to sum to 1.}
\item{\code{Ranks}}{Vector of ranks applied to the general dominance statistics.}
\item{\code{Conditional_Dominance}}{Matrix of Conditional dominance statistics.  Each row represents a term; each column represents an order of terms.}
\item{\code{Complete_Dominance}}{Logical matrix of Complete dominance designations. The term represented in each row indicates dominance status; the terms represented in each columns indicates dominated-by status.}
\item{\code{Fit_Statistic_Overall}}{Value of fit statistic for the full model.}
\item{\code{Fit_Statistic_All_Subset}}{Value of fit statistic associated with terms in \code{.all}.}
\item{\code{Fit_Statistic_Constant_Model}}{Value of fit statistic associated with terms in \code{consmodel}.}
\item{\code{Call}}{The matched call.}
\item{\code{Subset_Details}}{List containing the full model and descriptions of terms in the full model by source.}
}
}
\description{
Computes dominance statistics for predictive modeling
functions that accept a \code{formula}, \code{Formula}, or \code{list}.
}
\details{
\code{domin} automates the computation of all possible combination of entries to the dominance analysis (DA), the creation of \code{formula} objects based on those entries, the modeling calls/fit statistic capture, and the computation of all the dominance statistics for the user.

\code{domin} accepts only a "deconstructed" set of inputs and "reconstructs" them prior to formulating a coherent predictive modeling call.

One specific instance of this deconstruction is in generating the number of entries to the DA. The number of entries is taken as all the \code{terms} from \code{.obj} and the separate list element vectors from \code{.set}. The entries themselves are concatenated into a single formula, combined with the entries in \code{.all}, and submitted to the predictive modeling function in \code{reg}.  Each different combination of entries to the DA forms a different \code{formula} and thus a different model to estimate.

For example, consider this \code{domin} call:

\code{domin(y ~ x1 + x2, lm, list(summary, "r.squared"), .set = list(c("x3", "x4")), .all = c("c1", "c2"), data = mydata))}

This call records three entries and results in seven (i.e., \eqn{2^3 - 1}) different combinations:

\enumerate{
\item x1
\item x2
\item x3, x4
\item x1, x2
\item x1, x3, x4
\item x2, x3, x4
\item x1, x2, x3, x4
}

\code{domin} parses \code{.obj} to obtain all the terms in it and combines them with \code{.set}.  When parsing \code{.obj}, only the processing that is available in the \code{stats} package is applied.  Note that \code{domin} is not programmed to process terms of order > 1 (i.e., interactions/products) appropriately (i.e., only include in the presence of lower order component terms).

From these combinations, the predictive models are constructed and called. The predictive model call includes the entries in \code{.all}, applies the appropriate formula, and reconstructs the function itself. The seven combinations above imply the following series of predictive model calls:

\enumerate{
\item \code{lm(y ~ x1 + c1 + c2, data = mydata})
\item \code{lm(y ~ x2 + c1 + c2, data = mydata})
\item \code{lm(y ~ x3 + x4 + c1 + c2, data = mydata})
\item \code{lm(y ~ x1 + x2 + c1 + c2, data = mydata})
\item \code{lm(y ~ x1 + x3 + x4 + c1 + c2, data = mydata})
\item \code{lm(y ~ x2 + x3 + x4 + c1 + c2, data = mydata})
\item \code{lm(y ~ x1 + x2 + x3 + x4 + c1 + c2, data = mydata})
}

It is possible to use a \code{domin} with only set (i.e., no IVs in \code{.obj}; see examples below). There must be at least two entries to the DA for \code{domin} to run.

all the called predictive models are submitted to the fit extractor function implied by the entries in \code{fitstat}. Again applying the example above, all seven predictive models' objects would be individually passed as follows:

\code{summary(lm_obj)["r.squared"]}

where \code{lm_obj} is the model object returned by \code{lm}.

The entries to \code{fitstat} must be as a list and follow a specific structure:
\code{list(fit_function, element_name, ...)}
\describe{
\item{\code{fit_function}}{First element and function to be applied to the object produced by the \code{reg} function}
\item{\code{element_name}}{Second element and name of the element from the object returned by \code{fit_function} to be used as a fit statistic.  The fit statistic must be scalar-valued/length 1}
\item{\code{...}}{Subsequent elements and are additional arguments passed to \code{fit_function}}
}

In the case that the model object returned by \code{reg} includes its own fit statistic without the need for an extractor function, the user can apply an anonymous function following the required format to extract it.
}
\examples{
## Basic linear model with r-square

domin(mpg ~ am + vs + cyl, 
  lm, 
  list("summary", "r.squared"), 
  data = mtcars)


## Linear model including set

domin(mpg ~ am + vs + cyl, 
  lm, 
  list("summary", "r.squared"), 
  data = mtcars, 
  .set = list(c("carb", "gear"), c("disp", "wt")))


## Multivariate linear model with custom multivariate r-square function 
## and all subset variable

Rxy <- function(obj, names, data) {
   return(list("r2" = cancor(predict(obj), 
       as.data.frame(mget(names, as.environment(data))))[["cor"]][1]^2)) 
       }
       
domin(cbind(wt, mpg) ~ vs + cyl + am, 
  lm, 
  list("Rxy", "r2", c("mpg", "wt"), mtcars), 
  data = mtcars, 
  .all = c("carb"))


## Set only

domin(mpg ~ 1, 
  lm, 
  list("summary", "r.squared"), 
  data = mtcars, 
  .set = list(c("am", "vs"), c("cyl", "disp"), c("qsec", "carb")))
  
## Constant model using AIC

domin(mpg ~ am + carb + cyl, 
  lm, 
  list(function(x) list(aic = extractAIC(x)[[2]]), "aic"), 
  data = mtcars, 
  .rev = TRUE, consmodel = "1")
}
